)abbrev package EXHELPER ExpressionHelper
ExpressionHelper(R) : Exports == Implementation where

  R : Join(Comparable, PolynomialFactorizationExplicit, RetractableTo Integer, LinearlyExplicitOver Integer, CharacteristicZero, CoercibleFrom Integer, CommutativeRing, GcdDomain, IntegralDomain)

  E ==> Expression R
  PowerRecord ==> Record(val : E, exponent : Integer) 
  RR ==> RewriteRule(R, R, E)
  
  Exports == with

    factorOut : (List E, E) -> E
    factorOut : (E, E) -> E
    factorWhatPossible : E -> E

    assume_only : (E, Symbol) -> Symbol
    assume : (E, Symbol) -> Set Symbol
    assume : (E, List Symbol) -> Set Symbol
    assumed? : (E, Symbol) -> Boolean
    known? : (E, Symbol) -> Boolean
    positive? : E -> Boolean
    nonzero? : E -> Boolean
    known_integer? : E -> Boolean
    known_real? : E -> Boolean
    facts : E -> Set Symbol

    if R has PatternMatchable R and R has ConvertibleTo Pattern R then
      collapseSqrtSqr : E -> E

    expandTrigMultiples : E -> E

    trig2tan : E -> E
    trig2hyper : E -> E
    trig2exp : E -> E

    gammaCollapse : E -> E
    dilogCollapse : E -> E
    expandBinom : E -> E

  Implementation == add

    marks := empty() $ Table(E, Set Symbol)

    dividePower : (E, E) -> Union(E, "failed")
    dividePower(ex1, ex2) ==
        r1 := isPower ex1
        r2 := isPower ex2
        r1 case "failed" or r2 case "failed" => "failed"
        p1 : PowerRecord := r1 :: PowerRecord
        p2 : PowerRecord := r2 :: PowerRecord
        (p1.val ~= p2.val) => "failed"
        p1.val ^ (p1.exponent - p2.exponent)

    factorOutSum : (List E, E) -> Union(E, "failed")
    factorOutSum(ks, ex) ==
      (p1 := isPlus ex) case "failed" => "failed"
      summands : List E := p1 :: List E
      goodSummands := [] :: List E
      badSummands := [] :: List E
      for summand in summands repeat
        p2 := isTimes summand
        if p2 case "failed" then
          if # ks = 1 then
            k := ks.1
            div := dividePower(summand, k)
            if div case "failed" then
              badSummands := cons(summand, badSummands)
            else
              goodSummands := cons(div @ E, goodSummands)
          else
            badSummands := cons(summand, badSummands)
        else
          multipliers : List E := p2 :: List E
          if every?(k +-> member?(k, multipliers), ks) then
            restMults := multipliers
            for k in ks repeat
              restMults := remove(k, restMults)
            a2 := reduce(_*, restMults, 1)
            goodSummands := cons(a2, goodSummands)
          else
            badSummands := cons(summand, badSummands)

      ks1 := reduce(_*, ks)
      paren(reduce(_+, goodSummands, 0)) * ks1 + reduce(_+, badSummands, 0)

    factorOutProd : (List E, E) -> Union(E, "failed")
    factorOutProd(ks, ex) ==
      (p1 := isTimes ex) case "failed" => "failed"
      multipliers : List E := p1 :: List E
      newMultipliers := [factorOut(ks, a) for a in multipliers]
      reduce(_*, newMultipliers, 1)

    factorOut(ks : List E, ex : E) : E ==
      ex1 := factorOutSum(ks, ex)
      if ex1 case "failed" then
        ex2 := factorOutProd(ks, ex)
        ex2 case "failed" => ex
        ex2 :: E
      else
        ex1 :: E

    factorOut(k : E, ex : E) : E ==
      p1 := isTimes k
      p1 case "failed" => factorOut([k], ex)
      ks := p1 :: List E
      factorOut(ks, ex)

    common_factors : E -> Table(E, Integer)
    common_factors(ex) ==
      s := isPlus ex
      s case "failed" => empty()
      summands := s :: List E
      res := empty() $ Table(E, Integer)
      for summand in summands repeat
        p := isTimes summand
        if not (p case "failed") then
          factors := p :: List E
          for f in factors repeat
            res(f) := res(f, 0) + 1
      res

    FactorRecord ==> Record(key : E, entry : Integer)
    
    cmpFactorRecord : (FactorRecord, FactorRecord) -> Boolean
    cmpFactorRecord(f1, f2) ==
      f1.entry > f2.entry

    mostUsedFactor : E -> Union(FactorRecord, "failed")
    mostUsedFactor(ex) ==
      factors := common_factors(ex)
      empty? factors => "failed"
      rec := max(cmpFactorRecord, factors)
      rec

    factorWhatPossible(ex) ==
      m := mostUsedFactor ex
      m case "failed" => ex
      mostUsed := m :: FactorRecord
      r := factorOut(mostUsed.key, ex)
      r

    assume_only(ex, p) ==
      if key?(ex, marks) then
        insert!(p, marks(ex))
      else
        marks(ex) := set([p])
      p

    assume(ex : E, p : Symbol) : Set Symbol ==
      rs := set() :: Set Symbol
      insert!(assume_only(ex, p), rs)
      if p = 'integer then
        insert!(assume_only(ex, 'real), rs)
      if p = 'positive then
        insert!(assume_only(ex, 'real), rs)
      rs

    assume(ex : E, ps : List Symbol) : Set Symbol ==
      rs := set() :: Set Symbol
      for p in ps repeat
        rs := union(rs, assume(ex, p))
      rs

    assumed?(ex, p) ==
      if key?(ex, marks) then
        member?(p, marks(ex))
      else
        false

    positive?(ex) ==
      iex := retractIfCan(ex) :: Union(Integer, "failed")
      iex case Integer => iex > 0
      assumed?(ex, 'positive) => true

      s := isPlus ex
      if s case "failed" then
        s := isTimes ex
        s case "failed" => false
        mults := s :: List E
        every?(positive?, mults)
      else
        summands := s :: List E
        ok := every?(positive?, summands)
        ok

    nonzero?(ex) ==
      iex := retractIfCan(ex) :: Union(Integer, "failed")
      iex case Integer => iex ~= 0
      assumed?(ex, 'nonzero) => true
      s := isTimes ex
      s case "failed" => false
      mults := s :: List E
      every?(nonzero?, mults)

    known_integer?(ex) ==
      iex := retractIfCan(ex) :: Union(Integer, "failed")
      iex case Integer => true
      assumed?(ex, 'integer) => true

      s := isPlus ex
      if s case "failed" then
        s := isTimes ex
        s case "failed" => false
        mults := s :: List E
        every?(known_integer?, mults)
      else
        summands := s :: List E
        every?(known_integer?, summands)

    known_real?(ex) ==
      iex := retractIfCan(ex) :: Union(Integer, "failed")
      iex case Integer => true
      assumed?(ex, 'real) => true

      s := isPlus ex
      if s case "failed" then
        s := isTimes ex
        s case "failed" => false
        mults := s :: List E
        every?(known_real?, mults)
      else
        summands := s :: List E
        every?(known_real?, summands)

    known?(ex, p) ==
      p = 'positive => positive?(ex)
      p = 'nonzero => nonzero?(ex)
      p = 'integer => known_integer?(ex)
      p = 'real => known_real?(ex)
      false

    facts(ex) ==
      if key?(ex, marks) then
        marks(ex)
      else
        set([])

    if R has PatternMatchable R and R has ConvertibleTo Pattern R then
      collapseSqrtSqr(ex) ==
        x := new() $ Symbol
        xe : E := coerce x
        r := suchThat(rule(sqrt(xe^(2 :: E)), xe), [x], xs +-> positive?(xs.1)) :: RR
        applyRules([r], ex)$ApplyRules(R, R, E)

    sinSign : E -> E
    sinSign(n) ==
      two : E := 2 :: E
      (-1)^((n-1) quo two)*(1 - (-1)^n)/two

    cosSign : E -> E
    cosSign(n) ==
      two : E := 2 :: E
      (-1)^(n quo two)*(1 + (-1)^n)/two

    expandTrigMultiples(ex) ==
      x : E := coerce new() $ Symbol
      ns := new() $ Symbol
      n : E := coerce ns
      ms : Symbol := new() $ Symbol
      m : E := coerce ms
      cosR := suchThat(rule(cos(n*x), sum(binomial(n,m)*cosSign(m)*sin(x)^m*cos(x)^(n-m), equation(ms, 0..n)) $ FunctionSpaceSum(R,E)), [ns], xs +-> known_integer?(xs.1)) :: RR
      sinR := suchThat(rule(sin(n*x), sum(binomial(n,m)*sinSign(m)*sin(x)^m*cos(x)^(n-m), equation(ms, 0..n)) $ FunctionSpaceSum(R,E)), [ns], xs +-> known_integer?(xs.1)) :: RR
      applyRules([cosR, sinR], ex, 1) $ ApplyRules(R, R, E)

    trig2tan(ex) ==
      x : E := coerce new() $ Symbol
      tan2 : E := tan(x/(2::E))
      sinTan := rule(sin(x), (2*tan2/(tan2^2 + 1)) :: E) :: RR
      cosTan := rule(cos(x), (1-tan2^2)/(1+tan2^2)) :: RR
      applyRules([sinTan, cosTan], ex)$ApplyRules(R, R, E)

    trig2hyper(ex) ==
      i : E := sqrt(-1)
      x : E := coerce new() $ Symbol
      sinH := rule(sin(x), sinh(i*x)/i) :: RR
      cosH := rule(cos(x), cosh(i*x)) :: RR
      applyRules([sinH, cosH], ex) $ ApplyRules(R, R, E)

    trig2exp(ex) ==
      i : E := sqrt(-1)
      x : E := coerce new() $ Symbol
      two : E := 2 :: E
      sinR := rule(sin(x), (exp(i*x) - exp(-i*x))/(two*i)) :: RR
      cosR := rule(cos(x), (exp(i*x) + exp(-i*x))/two) :: RR
      applyRules([sinR, cosR], ex) $ ApplyRules(R, R, E)

    gammaCollapse(ex) ==
      z : E := coerce new() $ Symbol
      p : E := pi() :: E
      r1 := rule(Gamma(z)*Gamma(-z), -p/(z*sin(p*z))) :: RR
      r2 := rule(Gamma(z)*Gamma(1-z), p/sin(p*z)) :: RR
      -- r3 := rule(Gamma(1/2 + z)*Gamma(1/2 - z), p/cos(p*z)) :: RR
      r4 := rule(Gamma(1+z)*Gamma(1-z), (p*z)/sin(p*z)) :: RR
      -- applyRules([r1, r2, r3, r4], ex) $ ApplyRules(R, R, E)
      applyRules([r1,r2,r4], ex) $ ApplyRules(R, R, E)

    dilogCollapse(ex) ==
      z : E := coerce new() $ Symbol
      two : E := 2 :: E
      r1 := rule(dilog(z)+dilog(-z), dilog(z^two)/two) :: RR
      r2 := rule(dilog(1-z) + dilog(1 - 1/z), -log(z)^two/two) :: RR
      applyRules([r1, r2], ex) $ ApplyRules(R, R, E)

    expandBinom(ex) ==
      a : E := coerce new() $ Symbol
      b : E := coerce new() $ Symbol
      n : E := coerce new() $ Symbol
      ms : Symbol := new() $ Symbol
      m : E := coerce ms
      zero : E := 0 :: E
      r1 := rule((a+b)^n, sum(binomial(n,m)*a^m*b^(n-m), equation(ms, zero..n)) $ FunctionSpaceSum(R, E)) :: RR
      applyRules([r1], ex) $ ApplyRules(R, R, E)
    
