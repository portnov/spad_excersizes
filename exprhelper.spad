)abbrev package EXHELPER ExpressionHelper
ExpressionHelper(R) : Exports == Implementation where

  R : Join(Comparable, PolynomialFactorizationExplicit, RetractableTo Integer, LinearlyExplicitOver Integer, CharacteristicZero, CoercibleFrom Integer, Ring)

  E ==> Expression R
  PowerRecord ==> Record(val : E, exponent : Integer) 
  RR ==> RewriteRule(R, R, E)
  
  Exports == with

    dividePower : (E, E) -> Union(E, "failed")
    factorOut : (List E, E) -> E
    factorOut : (E, E) -> E

    assume : (E, Symbol) -> Symbol
    assumed? : (E, Symbol) -> Boolean
    known? : (E, Symbol) -> Boolean
    positive? : E -> Boolean
    facts : E -> Set Symbol

    if R has PatternMatchable R and R has ConvertibleTo Pattern R then
      collapseSqrtSqr : E -> E

    trig2tan : E -> E
    trig2hyper : E -> E
    trig2exp : E -> E

    gammaCollapse : E -> E

  Implementation == add

    marks := empty() $ Table(E, Set Symbol)

    dividePower(ex1, ex2) ==
        r1 := isPower ex1
        r2 := isPower ex2
        r1 case "failed" or r2 case "failed" => "failed"
        p1 : PowerRecord := r1 :: PowerRecord
        p2 : PowerRecord := r2 :: PowerRecord
        (p1.val ~= p2.val) => "failed"
        p1.val ^ (p1.exponent - p2.exponent)

    factorOutSum : (List E, E) -> Union(E, "failed")
    factorOutSum(ks, ex) ==
      (p1 := isPlus ex) case "failed" => "failed"
      summands : List E := p1 :: List E
      goodSummands := [] :: List E
      badSummands := [] :: List E
      for summand in summands repeat
        p2 := isTimes summand
        if p2 case "failed" then
          if # ks = 1 then
            k := ks.1
            div := dividePower(summand, k)
            if div case "failed" then
              badSummands := cons(summand, badSummands)
            else
              goodSummands := cons(div @ E, goodSummands)
          else
            badSummands := cons(summand, badSummands)
        else
          multipliers : List E := p2 :: List E
          if every?(k +-> member?(k, multipliers), ks) then
            restMults := multipliers
            for k in ks repeat
              restMults := remove(k, restMults)
            a2 := reduce(_*, restMults, 1)
            goodSummands := cons(a2, goodSummands)
          else
            badSummands := cons(summand, badSummands)

      ks1 := reduce(_*, ks)
      paren(reduce(_+, goodSummands, 0)) * ks1 + reduce(_+, badSummands, 0)

    factorOutProd : (List E, E) -> Union(E, "failed")
    factorOutProd(ks, ex) ==
      (p1 := isTimes ex) case "failed" => "failed"
      multipliers : List E := p1 :: List E
      newMultipliers := [factorOut(ks, a) for a in multipliers]
      reduce(_*, newMultipliers, 1)

    factorOut(ks : List E, ex : E) : E ==
      ex1 := factorOutSum(ks, ex)
      if ex1 case "failed" then
        ex2 := factorOutProd(ks, ex)
        ex2 case "failed" => ex
        ex2 :: E
      else
        ex1 :: E

    factorOut(k : E, ex : E) : E ==
      p1 := isTimes k
      p1 case "failed" => factorOut([k], ex)
      ks := p1 :: List E
      factorOut(ks, ex)

    assume(ex, p) ==
      if key?(ex, marks) then
        insert!(p, marks(ex))
      else
        marks(ex) := set([p])
      p

    assumed?(ex, p) ==
      if key?(ex, marks) then
        member?(p, marks(ex))
      else
        false

    positive?(ex) ==
      assumed?(ex, 'positive) => true
      iex := retractIfCan(ex) :: Union(Integer, "failed")
      iex case Integer => iex > 0

      s := isPlus ex
      if s case "failed" then
        s := isTimes ex
        s case "failed" => false
        mults := s :: List E
        every?(positive?, mults)
      else
        summands := s :: List E
        ok := every?(positive?, summands)
        ok

    known?(ex, p) ==
      if p = 'positive then
        positive?(ex)
      else
        false

    facts(ex) ==
      if key?(ex, marks) then
        marks(ex)
      else
        set([])

    if R has PatternMatchable R and R has ConvertibleTo Pattern R then
      collapseSqrtSqr(ex) ==
        x := new() $ Symbol
        xe : E := coerce x
        r := suchThat(rule(sqrt(xe^(2 :: E)), xe), [x], xs +-> positive?(xs.1)) :: RR
        applyRules([r], ex)$ApplyRules(R, R, E)

    trig2tan(ex) ==
      x : E := coerce new() $ Symbol
      tan2 : E := tan(x/(2::E))
      sinTan := rule(sin(x), (2*tan2/(tan2^2 + 1)) :: E) :: RR
      cosTan := rule(cos(x), (1-tan2^2)/(1+tan2^2)) :: RR
      applyRules([sinTan, cosTan], ex)$ApplyRules(R, R, E)

    trig2hyper(ex) ==
      i : E := sqrt(-1)
      x : E := coerce new() $ Symbol
      sinH := rule(sin(x), sinh(i*x)/i) :: RR
      cosH := rule(cos(x), cosh(i*x)) :: RR
      applyRules([sinH, cosH], ex) $ ApplyRules(R, R, E)

    trig2exp(ex) ==
      i : E := sqrt(-1)
      x : E := coerce new() $ Symbol
      two : E := 2 :: E
      sinR := rule(sin(x), (exp(i*x) - exp(-i*x))/(two*i)) :: RR
      cosR := rule(cos(x), (exp(i*x) + exp(-i*x))/two) :: RR
      applyRules([sinR, cosR], ex) $ ApplyRules(R, R, E)

    gammaCollapse(ex) ==
      z : E := coerce new() $ Symbol
      p : E := pi() :: E
      r1 := rule(Gamma(z)*Gamma(-z), -p/(z*sin(p*z))) :: RR
      r2 := rule(Gamma(z)*Gamma(1-z), p/sin(p*z)) :: RR
      -- r3 := rule(Gamma(1/2 + z)*Gamma(1/2 - z), p/cos(p*z)) :: RR
      r4 := rule(Gamma(1+z)*Gamma(1-z), (p*z)/sin(p*z)) :: RR
      -- applyRules([r1, r2, r3, r4], ex) $ ApplyRules(R, R, E)
      applyRules([r1,r2,r4], ex) $ ApplyRules(R, R, E)
    
